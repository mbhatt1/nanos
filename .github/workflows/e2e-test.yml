name: E2E Tests

on:
  push:
    branches:
      - master
  pull_request:
    branches:
      - master
  workflow_dispatch:
    inputs:
      timeout:
        description: 'QEMU timeout in seconds'
        required: false
        default: '180'
      verbose:
        description: 'Enable verbose output'
        required: false
        default: 'false'
        type: boolean

concurrency:
  group: e2e-${{ github.ref }}
  cancel-in-progress: true

env:
  QEMU_TIMEOUT: ${{ github.event.inputs.timeout || '180' }}

jobs:
  # ============================================================================
  # E2E Tests on Linux x86_64
  # ============================================================================
  e2e-linux-x86:
    name: E2E Linux x86_64
    runs-on: ubuntu-22.04
    timeout-minutes: 30
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.18'

      - name: Cache build artifacts
        uses: actions/cache@v3
        with:
          path: |
            ~/.cache/apt
            ~/go/pkg/mod
            output/
          key: ${{ runner.os }}-e2e-${{ hashFiles('**/Makefile', 'src/**/*.c', 'src/**/*.h') }}
          restore-keys: |
            ${{ runner.os }}-e2e-
            ${{ runner.os }}-build-

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            build-essential \
            nasm \
            qemu-system-x86 \
            wget

      - name: Enable KVM
        run: |
          echo 'KERNEL=="kvm", GROUP="kvm", MODE="0666", OPTIONS+="static_node=kvm"' | sudo tee /etc/udev/rules.d/99-kvm4all.rules
          sudo udevadm control --reload-rules
          sudo udevadm trigger --name-match=kvm

      - name: Build kernel and tools
        run: |
          echo "=== Building Authority Nanos Kernel ==="
          make -j$(nproc) PLATFORM=pc
          make -j$(nproc) -C tools mkfs
          ls -lh output/platform/pc/bin/kernel.img
          ls -lh output/platform/pc/boot/boot.img
          ls -lh output/tools/bin/mkfs

      - name: Build E2E test program
        run: |
          echo "=== Building E2E Test Program ==="
          cd test/e2e/authority
          gcc -O2 -Wall -Wextra -static -o test_basic test_basic.c
          file test_basic
          ls -lh test_basic

      - name: Create test disk image
        run: |
          echo "=== Creating Test Disk Image ==="
          cd test/e2e/authority

          # Create manifest
          cat > test_e2e.manifest << 'EOF'
          (
              children:(
                  test_basic:(contents:(host:test/e2e/authority/test_basic))
                  policy.json:(contents:(host:test/e2e/authority/test_policy.json))
                  tmp:(children:())
                  proc:(children:(
                      self:(children:(
                          status:(contents:"Name:\ttest_basic\nState:\tR (running)\n")
                      ))
                  ))
              )
              program:/test_basic
              debug_exit:t
              fault:t
              arguments:[test_basic e2e_test]
              environment:(USER:e2e_test PWD:/)
          )
          EOF

          # Create disk image
          cd ${{ github.workspace }}
          output/tools/bin/mkfs \
            -b output/platform/pc/boot/boot.img \
            -k output/platform/pc/bin/kernel.img \
            test/e2e/authority/test_e2e.img < test/e2e/authority/test_e2e.manifest

          ls -lh test/e2e/authority/test_e2e.img

      - name: Run E2E tests in QEMU
        id: qemu_test
        run: |
          echo "=== Running E2E Tests in QEMU ==="
          cd test/e2e/authority

          # Run QEMU with KVM acceleration
          set +e
          timeout ${{ env.QEMU_TIMEOUT }} qemu-system-x86_64 \
            -machine q35 \
            -cpu host \
            -m 512M \
            -display none \
            -serial stdio \
            -drive if=none,id=hd0,format=raw,file=test_e2e.img \
            -device virtio-scsi-pci,id=scsi0 \
            -device scsi-hd,bus=scsi0.0,drive=hd0 \
            -device isa-debug-exit \
            -no-reboot \
            -enable-kvm 2>&1 | tee e2e_output.log

          QEMU_EXIT=$?
          set -e

          echo "QEMU exit code: $QEMU_EXIT"
          echo "qemu_exit=$QEMU_EXIT" >> $GITHUB_OUTPUT

      - name: Analyze test results
        run: |
          echo "=== Analyzing E2E Test Results ==="
          cd test/e2e/authority

          # Show full output
          echo "--- Full Output ---"
          cat e2e_output.log
          echo "--- End Output ---"
          echo ""

          # Count results
          TESTS_PASSED=$(grep -c '\[TEST_PASS\]' e2e_output.log || echo 0)
          TESTS_FAILED=$(grep -c '\[TEST_FAIL\]' e2e_output.log || echo 0)

          echo "Tests passed: $TESTS_PASSED"
          echo "Tests failed: $TESTS_FAILED"

          # Check for success marker
          if grep -q '\[E2E\] TEST_SUITE_PASS' e2e_output.log; then
            echo ""
            echo "=== E2E Tests PASSED ==="
            exit 0
          elif grep -q '\[E2E\] TEST_SUITE_FAIL' e2e_output.log; then
            echo ""
            echo "=== E2E Tests FAILED ==="
            echo ""
            echo "Failed tests:"
            grep '\[TEST_FAIL\]' e2e_output.log || true
            exit 1
          elif grep -q '\[E2E\] TEST_SUITE_START' e2e_output.log; then
            # Suite started but didn't complete
            echo ""
            echo "=== E2E Test Suite Incomplete ==="
            if [ "$TESTS_FAILED" -eq 0 ] && [ "$TESTS_PASSED" -gt 0 ]; then
              echo "All completed tests passed"
              exit 0
            fi
            exit 1
          else
            echo ""
            echo "=== E2E Tests Failed to Start ==="
            exit 1
          fi

      - name: Upload test artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: e2e-linux-x86-logs
          path: |
            test/e2e/authority/e2e_output.log
            test/e2e/authority/test_basic
          retention-days: 7

  # ============================================================================
  # E2E Tests on macOS x86_64 (non-blocking)
  # ============================================================================
  e2e-macos-x86:
    name: E2E macOS x86_64
    runs-on: macos-15-intel
    timeout-minutes: 45
    continue-on-error: true
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Cache dependencies
        uses: actions/cache@v3
        with:
          path: |
            /Library/Caches/Homebrew
            output/
          key: ${{ runner.os }}-e2e-${{ hashFiles('**/Makefile') }}
          restore-keys: |
            ${{ runner.os }}-e2e-

      - name: Install dependencies
        run: |
          brew install nasm go wget qemu x86_64-elf-gcc x86_64-elf-binutils

      - name: Build kernel and tools
        run: |
          echo "=== Building Authority Nanos Kernel ==="
          make -j$(sysctl -n hw.ncpu) PLATFORM=pc CROSS_COMPILE=x86_64-elf-
          make -j$(sysctl -n hw.ncpu) -C tools mkfs
          ls -lh output/platform/pc/bin/kernel.img
          ls -lh output/platform/pc/boot/boot.img
          ls -lh output/tools/bin/mkfs

      - name: Build E2E test program
        id: build_test
        run: |
          echo "=== Building E2E Test Program ==="
          cd test/e2e/authority

          # The x86_64-elf-gcc cross-compiler is a bare-metal compiler without
          # libc headers. We need a cross-compiler with newlib/musl to build
          # userspace programs. For now, skip the E2E test on macOS.
          #
          # Note: The kernel and tools (mkfs) build correctly with x86_64-elf-gcc
          # because they don't depend on a hosted C library.

          if command -v x86_64-elf-gcc &> /dev/null; then
            # Test if the cross-compiler can compile a simple program with libc
            echo '#include <stdio.h>
            int main() { return 0; }' > /tmp/test_libc.c
            if x86_64-elf-gcc -c /tmp/test_libc.c -o /tmp/test_libc.o 2>/dev/null; then
              echo "Cross-compiler has libc headers, building test program..."
              x86_64-elf-gcc -O2 -Wall -Wextra -o test_basic test_basic.c
              file test_basic
              ls -lh test_basic
              echo "can_run_e2e=true" >> $GITHUB_OUTPUT
            else
              echo "Cross-compiler lacks libc headers (expected for bare-metal toolchain)"
              echo "Skipping E2E test on macOS - kernel/tools build verified successfully"
              echo "can_run_e2e=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "Cross-compiler not available"
            echo "can_run_e2e=false" >> $GITHUB_OUTPUT
          fi

      - name: Create test disk image
        if: success() && steps.build_test.outputs.can_run_e2e == 'true'
        run: |
          echo "=== Creating Test Disk Image ==="
          cd test/e2e/authority

          # Check if binary is correct format
          if ! file test_basic | grep -q "ELF 64-bit"; then
            echo "Binary is not ELF format, skipping QEMU test"
            exit 0
          fi

          # Create manifest
          cat > test_e2e.manifest << 'EOF'
          (
              children:(
                  test_basic:(contents:(host:test/e2e/authority/test_basic))
                  policy.json:(contents:(host:test/e2e/authority/test_policy.json))
                  tmp:(children:())
              )
              program:/test_basic
              debug_exit:t
              fault:t
              arguments:[test_basic e2e_test]
              environment:(USER:e2e_test PWD:/)
          )
          EOF

          # Create disk image
          cd ${{ github.workspace }}
          output/tools/bin/mkfs \
            -b output/platform/pc/boot/boot.img \
            -k output/platform/pc/bin/kernel.img \
            test/e2e/authority/test_e2e.img < test/e2e/authority/test_e2e.manifest

          ls -lh test/e2e/authority/test_e2e.img

      - name: Run E2E tests in QEMU
        if: success() && steps.build_test.outputs.can_run_e2e == 'true'
        run: |
          echo "=== Running E2E Tests in QEMU ==="
          cd test/e2e/authority

          # Check if disk image exists
          if [ ! -f test_e2e.img ]; then
            echo "No disk image, skipping QEMU test"
            exit 0
          fi

          # Check if binary is correct format
          if ! file test_basic | grep -q "ELF 64-bit"; then
            echo "Binary is not ELF format, skipping QEMU test"
            exit 0
          fi

          # Run QEMU with HVF acceleration
          set +e
          timeout ${{ env.QEMU_TIMEOUT }} qemu-system-x86_64 \
            -machine q35 \
            -m 512M \
            -display none \
            -serial stdio \
            -drive if=none,id=hd0,format=raw,file=test_e2e.img \
            -device virtio-scsi-pci,id=scsi0 \
            -device scsi-hd,bus=scsi0.0,drive=hd0 \
            -device isa-debug-exit \
            -no-reboot \
            -accel hvf -cpu host,-rdtscp 2>&1 | tee e2e_output.log

          QEMU_EXIT=$?
          set -e

          echo "QEMU exit code: $QEMU_EXIT"

      - name: Analyze test results
        if: success()
        run: |
          echo "=== Analyzing E2E Test Results ==="
          cd test/e2e/authority

          if [ ! -f e2e_output.log ]; then
            echo "No output log, test was skipped"
            exit 0
          fi

          # Show full output
          echo "--- Full Output ---"
          cat e2e_output.log
          echo "--- End Output ---"
          echo ""

          # Count results
          TESTS_PASSED=$(grep -c '\[TEST_PASS\]' e2e_output.log || echo 0)
          TESTS_FAILED=$(grep -c '\[TEST_FAIL\]' e2e_output.log || echo 0)

          echo "Tests passed: $TESTS_PASSED"
          echo "Tests failed: $TESTS_FAILED"

          # Check for success marker
          if grep -q '\[E2E\] TEST_SUITE_PASS' e2e_output.log; then
            echo "=== E2E Tests PASSED ==="
            exit 0
          elif grep -q '\[E2E\] TEST_SUITE_FAIL' e2e_output.log; then
            echo "=== E2E Tests FAILED ==="
            grep '\[TEST_FAIL\]' e2e_output.log || true
            exit 1
          elif grep -q '\[E2E\] TEST_SUITE_START' e2e_output.log; then
            if [ "$TESTS_FAILED" -eq 0 ] && [ "$TESTS_PASSED" -gt 0 ]; then
              echo "All completed tests passed"
              exit 0
            fi
            exit 1
          else
            echo "=== E2E Tests Failed to Start ==="
            exit 1
          fi

      - name: Upload test artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: e2e-macos-x86-logs
          path: |
            test/e2e/authority/e2e_output.log
            test/e2e/authority/test_basic
          retention-days: 7
          if-no-files-found: ignore

  # ============================================================================
  # E2E Test Summary
  # ============================================================================
  e2e-summary:
    name: E2E Test Summary
    runs-on: ubuntu-latest
    needs: [e2e-linux-x86]
    if: always()
    steps:
      - name: Check test results
        run: |
          echo "=== E2E Test Summary ==="
          echo ""
          echo "Linux x86_64: ${{ needs.e2e-linux-x86.result }}"
          echo "macOS x86_64: runs independently (continue-on-error)"
          echo ""

          # Linux is the primary platform
          if [ "${{ needs.e2e-linux-x86.result }}" != "success" ]; then
            echo "Linux E2E tests failed"
            exit 1
          fi

          echo "E2E tests completed successfully"
